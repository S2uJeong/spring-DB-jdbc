## 체크와 언체크예외
- 의미상 차이 : 예외를 처리 할 수 없을 때 던지는 것을 생략가능한지 생략불가한지
- 컴파일러 입장에서 체크하는지가 체크/언체크 예외임

### 체크예외
- `Exception`
- `try-catch` or `throws` 를 하지 않으면 컴파일러 에러가 발생한다.
- 장점 : 훌륭한 안전장치
- 단점 : 번거롭다. 많은 라이브러리를 쓸땐 더더욱,, + 의존관계에 따른 단점 (어차피 내가 처리 못해!!!)

### 언체크예외
- `RuntimeException`
- 예외를 잡아서 처리하지 않아도 throws 생략가능

### 기본적으로 언체크 예외를 사용하자
- 체크 예외 문제점
  - 복구 불가능한 예외 : 시스템레벨 문제로 발생하는 에러를 다른 계층에서도 해결할 수 없다.
    - 대부분의 예외는 복구가 불가능 하다.
    - 이런 문제들을 일관성 있게 공통으로 처리하는게 낫다.
    - 서블릿 필터, 스프링 인터셉터, 스프링의 `ControllerAdvice` 사용 
  - 의존 관계에 대한 문제
    - Service, Controller 계층에서도 `SQLException`을 의존하게 된다.  
    
### 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자.
- 예외를 잡아서 반드시 처리해야 하는 문제
- 계좌 이체 실패, 결제시 포인트 부족 예외 등 

### 런타임 예외는 문서화를 잘해야 한다.
- 문서화
- 코드에 생략가능하지만 굳이 throws로 적어 놓기

## 예외 포함과 스택 트레이스
### 예외 전환 시 꼭 이전 예외를 포함시킬 것 


## 스프링의 예외처리, 반복
### Repository 인터페이스 제작 
- 인터페이스 구현체가 예외를 던지려면, 인터페이스 메서드에 먼저 체크 예외를 던지는 부분이 선언 되어 있어야 한다.
- 구현 기술을 쉽게 변경하기 위해서 인터페이스를 도입하더라도 `SQLException`과 같은 특정 구현 기술에 종속적인 체크 예외를 사용하게 되면 순수한 인터페이스가 아니게 된다. 
- 따라서 리포지토리 구현체에서 언체크 예외로 전환해줌으로써 서비스계층을 순수한 로직으로 만들 수 있다.

### 데이터 접근 예외 직접 만들기 
- 특정 상황에서는 서비스계층에서 예외를 잡아서 복구하고 싶다. 어떻게 예외를 구분해서 처리 할 수 있을까?
  - 리포지토리에서 예외를 기술에 의존하지 않게 개발자가 직접 만든 예외를 변환해서 던진다!
  - `SQLException` -> `MyDuplicateKeyException`
  - 이후 나오는 스프링 예외 추상화를 이용하면 해당 오류에 대한 처리 코드를 쉽게 구성할 수 있다. 
- 그런데,, DBMS마다 ErrorCode가 다 다르고 수백가지 오류 코드가 있는데 어떻게 다 커버가 가능하지? -> 스프링 예외 추상화

### 스프링 예외 추상화
- 스프링은 데이터 접근과 관련된 예외를 추상화해서 제공한다. 
  - note/스프링 데이터접근 예외계층.png
- 따라서 스프링이 제공하는 예외를 사용하면 기술 종속적이지 않게 설계할 수 있다. (물론 스프링에 의존적이긴 하다.ㅎ)
  - 스프링이 제공하는 데이터접근 계층의 모든 예외는 런타임 예외이다. `DataAccessException`에서 상속받은
    - `Transient` 
      - 일시적 예외, 이 예외의 하위는 SQL을 다시 시도했을 때 성공할 가능성이 있다.
      - 쿼리 타임아웃, 락과 관련된 오류 
    - `NonTransient`
      - SQL 반복 실행 시 실패한다
      - SQL 문법 오류, 데이터베이스 제약조건 위해 등 
- 스프링은 DB에서 발생하는 오류 코드를 스프링이 정의한 예외로 자동으로 변환해주는 변환기를 제공한다. 
  - `sql-error-code.xml` 이용해서 가능하게 함 

## JDBC 반복 문제 해결 - JDBCTemplate
- sql이랑 바인딩 부분만 바뀌고 나머진 중복된다. 
- 