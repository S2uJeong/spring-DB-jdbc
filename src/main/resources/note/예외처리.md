## 체크와 언체크예외
- 의미상 차이 : 예외를 처리 할 수 없을 때 던지는 것을 생략가능한지 생략불가한지
- 컴파일러 입장에서 체크하는지가 체크/언체크 예외임

### 체크예외
- `Exception`
- `try-catch` or `throws` 를 하지 않으면 컴파일러 에러가 발생한다.
- 장점 : 훌륭한 안전장치
- 단점 : 번거롭다. 많은 라이브러리를 쓸땐 더더욱,, + 의존관계에 따른 단점 (어차피 내가 처리 못해!!!)

### 언체크예외
- `RuntimeException`
- 예외를 잡아서 처리하지 않아도 throws 생략가능

### 기본적으로 언체크 예외를 사용하자
- 체크 예외 문제점
  - 복구 불가능한 예외 : 시스템레벨 문제로 발생하는 에러를 다른 계층에서도 해결할 수 없다.
    - 대부분의 예외는 복구가 불가능 하다.
    - 이런 문제들을 일관성 있게 공통으로 처리하는게 낫다.
    - 서블릿 필터, 스프링 인터셉터, 스프링의 `ControllerAdvice` 사용 
  - 의존 관계에 대한 문제
    - Service, Controller 계층에서도 `SQLException`을 의존하게 된다.  
    
### 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에만 사용하자.
- 예외를 잡아서 반드시 처리해야 하는 문제
- 계좌 이체 실패, 결제시 포인트 부족 예외 등 

### 런타임 예외는 문서화를 잘해야 한다.
- 문서화
- 코드에 생략가능하지만 굳이 throws로 적어 놓기

## 예외 포함과 스택 트레이스
### 예외 전환 시 꼭 이전 예외를 포함시킬 것 


## 스프링의 예외처리, 반복
### Repository 인터페이스 제작 
- 인터페이스 구현체가 예외를 던지려면, 인터페이스 메서드에 먼저 체크 예외를 던지는 부분이 선언 되어 있어야 한다.
- 구현 기술을 쉽게 변경하기 위해서 인터페이스를 도입하더라도 `SQLException`과 같은 특정 구현 기술에 종속적인 체크 예외를 사용하게 되면 순수한 인터페이스가 아니게 된다. 
- 따라서 리포지토리 구현체에서 언체크 예외로 전환해줌으로써 서비스계층을 순수한 로직으로 만들 수 있다.

### 데이터 접근 예외 직접 만들기 
- 특정 상황에서는 서비스계층에서 예외를 잡아서 복구하고 싶다. 어떻게 예외를 구분해서 처리 할 수 있을까?
  - 리포지토리에서 예외를 기술에 의존하지 않게 개발자가 직접 만든 예외를 변환해서 던진다!
  - `SQLException` -> `MyDuplicateKeyException`
- 그런데,, DBMS마다 ErrorCode가 다 다르고 수백가지 오류 코드가 있는데 어떻게 다 커버가 가능하지? -> 스프링 예외 추상화

### 스프링 예외 추상화
